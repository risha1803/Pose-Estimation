# -*- coding: utf-8 -*-
"""GMMFinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WAEMekINfrvCg4IMyKqJ9SiJ9zY2ojus

#**IMPORTING KAGGLE DATASET**
"""

import os
os.environ['KAGGLE_USERNAME']="simransagar08"
os.environ['KAGGLE_KEY']="1ef425667c8eb27c590a5d4f1b2ff1e2"

!kaggle datasets download -d jithinnambiarj/human-activity-detection-dataset

!unzip human-activity-detection-dataset.zip

"""# **MMPOSE**

# Installing the requirements
"""

# Commented out IPython magic to ensure Python compatibility.
# install dependencies: (use cu111 because colab has CUDA 11.1)
# %pip install torch==1.10.0+cu111 torchvision==0.11.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html

# install mmcv-full thus we could use CUDA operators
# %pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.10.0/index.html

# install mmdet for inference demo
# %pip install mmdet

# clone mmpose repo
# %rm -rf mmpose
!git clone https://github.com/open-mmlab/mmpose.git
# %cd mmpose

# install mmpose dependencies
# %pip install -r requirements.txt

# install mmpose in develop mode
# %pip install -e .

# Check Pytorch installation
import torch, torchvision

print('torch version:', torch.__version__, torch.cuda.is_available())
print('torchvision version:', torchvision.__version__)

# Check MMPose installation
import mmpose

print('mmpose version:', mmpose.__version__)

# Check mmcv installation
from mmcv.ops import get_compiling_cuda_version, get_compiler_version

print('cuda version:', get_compiling_cuda_version())
print('compiler information:', get_compiler_version())

import cv2
from mmpose.apis import (inference_top_down_pose_model, init_pose_model,
                         vis_pose_result, process_mmdet_results)
from mmdet.apis import inference_detector, init_detector

local_runtime = False

try:
    from google.colab.patches import cv2_imshow  # for image visualization in colab
except:
    local_runtime = True

pose_config = 'configs/body/2d_kpt_sview_rgb_img/topdown_heatmap/coco/hrnet_w48_coco_256x192.py'
pose_checkpoint = 'https://download.openmmlab.com/mmpose/top_down/hrnet/hrnet_w48_coco_256x192-b9e0b3ab_20200708.pth'
det_config = 'demo/mmdetection_cfg/faster_rcnn_r50_fpn_coco.py'
det_checkpoint = 'https://download.openmmlab.com/mmdetection/v2.0/faster_rcnn/faster_rcnn_r50_fpn_1x_coco/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'

# initialize pose model
pose_model = init_pose_model(pose_config, pose_checkpoint)
# initialize detector
det_model = init_detector(det_config, det_checkpoint)

"""# Calculating Keypoints"""

img = cv2.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')
mmdet_results = inference_detector(det_model, img)

person_results = process_mmdet_results(mmdet_results, cat_id=1)

pose_results, returned_outputs = inference_top_down_pose_model(
    pose_model,
    img,
    person_results,
    bbox_thr=0.3,
    format='xyxy',
    dataset=pose_model.cfg.data.test.type)
i = pose_results[0]['keypoints'].tolist()

#REMOVING THE NON REQUIRED BODYPARTS
del i[0:5]  
print(i)

#REMOVING THE VISIBILITY SCORE FROM THE DATA (x,y,vis)
for z in i:
  z.pop(2) 

print(i)

#MANUALLY GROUPING OUR CLUSTERS TO GENERATE TRUE LABELS FOR LATER EVALUATION
ul = i[0:5:2]    
ur = i[1:6:2]
lr = i[7:12:2]
ll = i[6:12:2]

print(ll)

"""# Importing the required libraries"""

import numpy as np
import pandas as pd
from itertools import chain
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.mixture import GaussianMixture
from sklearn.metrics import classification_report

#CREATING ARRAYS FOR DATAFRAME 
ur_x = np.array([[i[0] for i in ur]])
ur_y = np.array([[i[1] for i in ur]])

ul_x = np.array([[i[0] for i in ul]])
ul_y = np.array([[i[1] for i in ul]])

lr_x = np.array([[i[0] for i in lr]])
lr_y = np.array([[i[1] for i in lr]])

ll_x = np.array([[i[0] for i in ll]])
ll_y = np.array([[i[1] for i in ll]])

print(ur_x)

#CREATING OUR DATAFRAME
d = pd.DataFrame({ 'X': ur_x[0], 'Y': ur_y[0],'label': 2})
d1 = pd.DataFrame({ 'X': ul_x[0], 'Y': ul_y[0],'label': 0})
d2 = pd.DataFrame({ 'X': lr_x[0], 'Y': lr_y[0],'label': 3})
d3 = pd.DataFrame({ 'X': ll_x[0], 'Y': ll_y[0],'label': 1})

frames = [d, d1, d2, d3]
res = pd.concat(frames)
res

"""# Applying the Gaussian Mixture Model for clustering"""

X = res[['X','Y']]      
gmm = GaussianMixture(n_components=4, max_iter=100)
gmm.fit(res)
labels = gmm.predict(res)
labels = np.array([1 if label==1 else label for label in labels])

prediction_df = res.copy()
prediction_df['gmm_label'] = labels

plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')

#LABELS FOR GRAPH LEGEND 
g_label = np.array(['Upper Left', 'Lower Left', 'Upper Right', 'Lower Right'])

"""# VISUALISING GMM CLUSTERS ON THE IMAGE """

from matplotlib.patches import Ellipse

#FUNCTION TO DRAW ELLIPSE AT THE REQUIRED LOCATION
def draw_ellipse(position, covariance, c1, l, ax=None, **kwargs):
    """Draw an ellipse with a given position and covariance"""
    ax = ax or plt.gca()
    # Convert covariance to principal axes
    if covariance.shape == (2, 2):
        
        U, s, Vt = np.linalg.svd(covariance)
        angle = np.degrees(np.arctan2(U[1, 0], U[0, 0]))
        width, height = 2 * np.sqrt(s)
        height = 20
    else:
        angle = 0
        width, height = 2 * np.sqrt(covariance)    
    # Draw the Ellipse
    for nsig in range(1, 4):
        ax.add_patch(Ellipse(position, nsig * width, nsig * height, angle, edgecolor = 'black', fc = c1, label = l,  **kwargs))
           
#FUNCTION TO PLOT CLUSTERS
def plot_gmm(gmm, X, label=True, ax=None):
    ax = ax or plt.gca()
    labels = gmm.fit(X).predict(X)
    labels = np.array([1 if label==1 else label for label in labels])
    prediction_df = res.copy()
    prediction_df['gmm_label'] = labels
    ax.axis('equal')
    w_factor = 0.2 / gmm.weights_.max()
    #plotting imagge
    im = plt.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')
    implot = plt.imshow(im)
    colors = np.array(['red', 'c', 'lawngreen', 'purple'])
    if label:
      plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')
    else:
        ax.scatter(res['X'], res['Y'], s=40, zorder=2)
    ax.axis('equal')
    for pos, covar, w, c1, l in zip(gmm.means_, gmm.covariances_, gmm.weights_, colors, g_label):
        draw_ellipse(pos, covar, c1, l,  alpha=w * w_factor)
    #Plotting legend and removing the repeatition 
    handles, labels = plt.gca().get_legend_handles_labels()
    by_label = dict(zip(labels, handles))    
    plt.legend(by_label.values(), by_label.keys())
    plt.show()
    return prediction_df

pred = plot_gmm(gmm, X)

pred

"""# ANALYZING THE CLUSTERING ACCURACY

RESULTS PER CLUSTER
"""

import pandas as pd
import numpy as np
from sklearn.metrics import classification_report, roc_auc_score
n = len(ll)
print("Upper Right")
print(classification_report(pred['label'][:n], pred['gmm_label'][:n]))
print("Upper Left")
print(classification_report(pred['label'][n:2*n], pred['gmm_label'][n:2*n]))
print("Lower Right")
print(classification_report(pred['label'][2*n:3*n], pred['gmm_label'][2*n:3*n]))
print("Lower Left")
print(classification_report(pred['label'][3*n:], pred['gmm_label'][3*n:]))

"""COMBINED RESULTS OF ALL THE CLUSTERS"""

print(classification_report(pred['label'], pred['gmm_label']))

"""# **BLAZEPOSE**

# Installing the requirements
"""

!pip install numpy==1.19.3
!pip install opencv-python==4.5.1.48
!pip install tqdm==4.56.0
!pip install mediapipe==0.8.3

"""# Calculating Keypoints"""

import csv
import cv2
import numpy as np
import os
import tqdm
import glob

from mediapipe.python.solutions import drawing_utils as mp_drawing
from mediapipe.python.solutions import pose as mp_pose


img =cv2.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')

      # Initialize fresh pose tracker and run it.
with mp_pose.Pose(upper_body_only=False) as pose_tracker:
  result = pose_tracker.process(image=img)
  pose_landmarks = result.pose_landmarks
if pose_landmarks is not None:
  p = [[lmk.x, lmk.y, lmk.z] for lmk in pose_landmarks.landmark]
  sc = [lmk.visibility for lmk in pose_landmarks.landmark]
      # Map pose landmarks from [0, 1] range to absolute coordinates to get
      # correct aspect ratio.
  frame_height, frame_width = img.shape[:2]
  p *= np.array([frame_width, frame_height, 0])
  p += np.array([0,0,1])

  i = p.astype(np.float).tolist()
  
#REMOVING THE NON REQUIRED PARTS
del i[0:11]

#REMOVING THE Z COORDINATE (x,y,z)
for z in i:
  z.pop(2)

print(i)
print(len(i))

#MANUALLY GROUPING OUR CLUSTERS TO GENERATE TRUE LABELS FOR LATER EVALUATION
ul = i[0:12:2]
ur = i[1:13:2]
lr = i[12::2]
ll = i[13::2]

print(len(ll))

#CREATING ARRAYS FOR DATAFRAME 
ur_x = np.array([[i[0] for i in ur]])
ur_y = np.array([[i[1] for i in ur]])

ul_x = np.array([[i[0] for i in ul]])
ul_y = np.array([[i[1] for i in ul]])

lr_x = np.array([[i[0] for i in lr]])
lr_y = np.array([[i[1] for i in lr]])

ll_x = np.array([[i[0] for i in ll]])
ll_y = np.array([[i[1] for i in ll]])

print(ur_x)

#CREATING OUR DATAFRAME
d = pd.DataFrame({ 'X': ur_x[0], 'Y': ur_y[0],'label': 0})
d1 = pd.DataFrame({ 'X': ul_x[0], 'Y': ul_y[0],'label': 2})
d2 = pd.DataFrame({ 'X': lr_x[0], 'Y': lr_y[0],'label': 3})
d3 = pd.DataFrame({ 'X': ll_x[0], 'Y': ll_y[0],'label': 1})

frames = [d, d1, d2, d3]
res = pd.concat(frames)
res

"""# Applying the Gaussian Mixture Model for clustering"""

X = res[['X','Y']]
gmm = GaussianMixture(n_components=4, max_iter=100)
gmm.fit(res)
labels = gmm.predict(res)
labels = np.array([1 if label==1 else label for label in labels])


prediction_df = res.copy()

prediction_df['gmm_label'] = labels

plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')

"""# VISUALISING GMM CLUSTERS ON IMAGE"""

from matplotlib.patches import Ellipse

#FUNCTION TO DRAW ELLIPSE AT THE REQUIRED LOCATION
def draw_ellipse(position, covariance, c1, l, ax=None, **kwargs):
    """Draw an ellipse with a given position and covariance"""
    ax = ax or plt.gca()
    # Convert covariance to principal axes
    if covariance.shape == (2, 2):
        
        U, s, Vt = np.linalg.svd(covariance)
        angle = np.degrees(np.arctan2(U[1, 0], U[0, 0]))
        width, height = 2 * np.sqrt(s)
        height = 20
    else:
        angle = 0
        width, height = 2 * np.sqrt(covariance)    
    # Draw the Ellipse
    for nsig in range(1, 4):
        ax.add_patch(Ellipse(position, nsig * width, nsig * height, angle, edgecolor = 'black', fc = c1, label = l,  **kwargs))
           
#FUNCTION TO PLOT CLUSTERS
def plot_gmm(gmm, X, label=True, ax=None):
    ax = ax or plt.gca()
    labels = gmm.fit(X).predict(X)
    labels = np.array([1 if label==1 else label for label in labels])
    prediction_df = res.copy()
    prediction_df['gmm_label'] = labels
    ax.axis('equal')
    w_factor = 0.2 / gmm.weights_.max()
    #plotting imagge
    im = plt.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')
    implot = plt.imshow(im)
    colors = np.array(['red', 'c', 'lawngreen', 'purple'])
    if label:
      plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')
    else:
        ax.scatter(res['X'], res['Y'], s=40, zorder=2)
    ax.axis('equal')
    for pos, covar, w, c1, l in zip(gmm.means_, gmm.covariances_, gmm.weights_, colors, g_label):
        draw_ellipse(pos, covar, c1, l,  alpha=w * w_factor)
    #Plotting legend and removing the repeatition 
    handles, labels = plt.gca().get_legend_handles_labels()
    by_label = dict(zip(labels, handles))    
    plt.legend(by_label.values(), by_label.keys())
    plt.show()
    return prediction_df

pred = plot_gmm(gmm, X)

pred

"""# ANALYZING THE CLUSTERING ACCURACY

RESULTS PER CLUSTER
"""

import pandas as pd
import numpy as np
from sklearn.metrics import classification_report, roc_auc_score
print("Upper Right")
print(classification_report(pred['label'][:6], pred['gmm_label'][:6]))
print("Upper Left")
print(classification_report(pred['label'][6:12], pred['gmm_label'][6:12]))
print("Lower Right")
print(classification_report(pred['label'][12:17], pred['gmm_label'][12:17]))
print("Lower Left")
print(classification_report(pred['label'][17:], pred['gmm_label'][17:]))

"""COMBINED RESULTS OF ALL THE CLUSTERS"""

print(classification_report(pred['label'], pred['gmm_label']))

"""# **KEYPOINT RCNN**

# Importing the requirements
"""

import torchvision
import cv2
import torch
import numpy as np
import matplotlib.pyplot as plt
import os
# create a model object from the keypointrcnn_resnet50_fpn class
model = torchvision.models.detection.keypointrcnn_resnet50_fpn(pretrained=True)
# call the eval() method to prepare the model for inference mode.
model.eval()

"""# Calculating Keypoints"""

import itertools
import cv2
import csv
# import the transforms module
import torch
from torchvision import transforms as T

transform = T.Compose([T.ToTensor()])

img = cv2.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')

img_tensor = transform(img)

output = model([img_tensor])[0]
i = output['keypoints'][0].tolist()
#REMOVING THE NON REQUIRED BODYPARTS
del i[0:5]
print(i)

#REMOVING THE VISIBILITY VARIABLE FROM DATA (x,y,vis)
for z in i:
  z.pop(2)

print(i)
print(len(i))

#MANUALLY GROUPING OUR CLUSTERS TO GENERATE TRUE LABELS FOR LATER EVALUATION
ul = i[0:5:2]
ur = i[1:6:2]
lr = i[7:12:2]
ll = i[6:12:2]

print(ll)

#CREATING ARRAYS FOR DATAFRAME
ur_x = np.array([[i[0] for i in ur]])
ur_y = np.array([[i[1] for i in ur]])

ul_x = np.array([[i[0] for i in ul]])
ul_y = np.array([[i[1] for i in ul]])

lr_x = np.array([[i[0] for i in lr]])
lr_y = np.array([[i[1] for i in lr]])

ll_x = np.array([[i[0] for i in ll]])
ll_y = np.array([[i[1] for i in ll]])

print(ur_x)

#CREATING OUR DATAFRAME
d = pd.DataFrame({ 'X': ur_x[0], 'Y': ur_y[0],'label': 0})
d1 = pd.DataFrame({ 'X': ul_x[0], 'Y': ul_y[0],'label': 2})
d2 = pd.DataFrame({ 'X': lr_x[0], 'Y': lr_y[0],'label': 3})
d3 = pd.DataFrame({ 'X': ll_x[0], 'Y': ll_y[0],'label': 1})

frames = [d, d1, d2, d3]
res = pd.concat(frames)
res

"""# Applying the Gaussian Mixture Model for clustering"""

X = res[['X','Y']]
gmm = GaussianMixture(n_components=4, max_iter=100)
gmm.fit(res)
labels = gmm.predict(res)
labels = np.array([1 if label==1 else label for label in labels])


prediction_df = res.copy()

prediction_df['gmm_label'] = labels

plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')

"""# VISUALISING GMM CLUSTERS ON IMAGE"""

from matplotlib.patches import Ellipse

#FUNCTION TO DRAW ELLIPSE AT THE REQUIRED LOCATION
def draw_ellipse(position, covariance, c1, l, ax=None, **kwargs):
    """Draw an ellipse with a given position and covariance"""
    ax = ax or plt.gca()
    # Convert covariance to principal axes
    if covariance.shape == (2, 2):
        
        U, s, Vt = np.linalg.svd(covariance)
        angle = np.degrees(np.arctan2(U[1, 0], U[0, 0]))
        width, height = 2 * np.sqrt(s)
        height = 20
    else:
        angle = 0
        width, height = 2 * np.sqrt(covariance)    
    # Draw the Ellipse
    for nsig in range(1, 4):
        ax.add_patch(Ellipse(position, nsig * width, nsig * height, angle, edgecolor = 'black', fc = c1, label = l,  **kwargs))
           
#FUNCTION TO PLOT CLUSTERS
def plot_gmm(gmm, X, label=True, ax=None):
    ax = ax or plt.gca()
    labels = gmm.fit(X).predict(X)
    labels = np.array([1 if label==1 else label for label in labels])
    prediction_df = res.copy()
    prediction_df['gmm_label'] = labels
    ax.axis('equal')
    w_factor = 0.2 / gmm.weights_.max()
    #plotting imagge
    im = plt.imread('/content/Activity Dataset/Activity Dataset/Sitting/img341.jpg')
    implot = plt.imshow(im)
    colors = np.array(['red', 'c', 'lawngreen', 'purple'])
    if label:
      plt.scatter(res['X'], res['Y'], c=labels, cmap='viridis')
    else:
        ax.scatter(res['X'], res['Y'], s=40, zorder=2)
    ax.axis('equal')
    for pos, covar, w, c1, l in zip(gmm.means_, gmm.covariances_, gmm.weights_, colors, g_label):
        draw_ellipse(pos, covar, c1, l,  alpha=w * w_factor)
    #Plotting legend and removing the repeatition 
    handles, labels = plt.gca().get_legend_handles_labels()
    by_label = dict(zip(labels, handles))    
    plt.legend(by_label.values(), by_label.keys())
    plt.show()
    return prediction_df

pred = plot_gmm(gmm, X)

pred

"""# ANALYZING THE CLUSTERING ACCURACY

RESULTS PER CLUSTER
"""

import pandas as pd
import numpy as np
from sklearn.metrics import classification_report, roc_auc_score
n = len(ll)
print("Upper Right")
print(classification_report(pred['label'][:n], pred['gmm_label'][:n]))
print("Upper Left")
print(classification_report(pred['label'][n:2*n], pred['gmm_label'][n:2*n]))
print("Lower Right")
print(classification_report(pred['label'][2*n:3*n], pred['gmm_label'][2*n:3*n]))
print("Lower Left")
print(classification_report(pred['label'][3*n:], pred['gmm_label'][3*n:]))

"""COMBINED RESULTS OF ALL THE CLUSTERS"""

print(classification_report(pred['label'], pred['gmm_label']))